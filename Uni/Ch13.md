# 13장. 쓰레드 동기화 기법 1

<br/>

## 1. 쓰레드 동기화란 무엇인가?

<br/>

### 두 가지 관점에서의 쓰레드 동기화

<br/>

- 동기화: '일치한다'는 의미에서의 동기화가 아닌, 순서에 의해서 질서가 지켜지고 있음을 의미하는 동기화이다.

<br/>

**실행순서의 동기화**

<br/>

- 쓰레드의 실행 순서를 정의하고, 이 순서에 반드시 따르도록 하는 것
- 접근의 순서가 이미 정해져 있는 상황에서, 그 순서만 지켜지면 된다.

<br/>

**메모리 접근에 대한 동기화**

<br/>

- 메모리 접근에 있어서 동시접근을 막는 것
- 예를 들어, 한 순간에 하나의 쓰레드에만 접근해야 하는 메모리 영역이 존재한다. 대표적으로 데이터 영역과 힙 영역이 있다.
    - 이 때, 데이터 영역에 할당된 변수를 둘 이상의 쓰레드가 동시에 접근할 때, 데이터가 덮어써지는 문제가 발생
- 실행의 순서가 중요한 상황이 아니고, 한 순간에 하나의 쓰레드만 접근하면 되는 상황이다. 
- 어떠한 순서로 실행되는지는 중요하지 않지만, 메모리에 동시접근하는 문제점만 발생하지 않으면 된다.

<br/>

**앞서 말한 두 가지 형태의 쓰레드 동기화는 모두 실행에 있어서 순서를 중요시한다.**

<br/>

### 쓰레드 동기화에 있어서 두 가지 방법

<br/>

- Windowsd에서 제공하는 동기화 기법은 제공하는 주체에 따라 크게 두 가지로 나뉜다.

<br/>

**유저 모드 동기화**

<br/>

- 동기화가 진행되는 과정에서 커널 코드가 실행되지 않는 동기화 기법
- 동기화를 위해서 커널 모드로의 전환이 불필요하기 때문에 성능에 이점이 있다.
- 하지만, 그만큼 기능상의 제한도 존재한다.

<br/>

**커널 모드 동기화**

<br/>

- 커널에서 제공하는 동기화 기능을 활용하는 방법
- 동기화에 관련된 함수가 호출도리 때 마다 커널 모드로의 변경이 필요하고, 이는 성능의 저하로 이어짐
- 하지만 그만큼 유저 모드 동기화에서 제공하지 못하는 기능을 제공받을 수 있다.

<br/>

**유저 모드 동기화와 커널 모드 동기화 모두 각각의 장단점이 존재한다.**

<br/>

## 2. 임계 영역(Critical Section) 접근 동기화

<br/>

- 메모리 영역의 접근을 동기화한다는 것은 '임계 영역의 접근을 동기화'하겠다는 뜻으로 해석할 수 있다.

<br/>

### 임계 영역에 대한 이해

<br/>

- 예를 들어, 하나의 전역변수에 접근하는 연산을 한다고 가정하자.
- 이 연산을 둘 이상의 쓰레드가 동시에 실행할 경우에 문제가 발생할 수 있다.
- 이러한 문제를 일으키는 코드 블록을 가리켜 **임계 영역**이라고 한다.
- 즉, 문제의 원인이 될 수 있는 코드의 블록을 가리켜 임계 영역이라고 하는 것이지, 전역 변수에 할당된 메모리 공간을 가리켜 임계 영역이라고 하는 것은 아니다.

<br/>

**임계 영역이란 배타적 접근(한 순간에 하나의 쓰레드만 접근)이 요구되는 공유 리소스(전역변수와 같은)에 접근하는 코드 블록을 의미한다.**

<br/>

### 앞서 언급한 예시의 문제점에 대한 해결책

<br/>

- 임계 영역의 동시 접근을 막는 것
- 즉, 동기화 기법을 통해서 임계 영역은 한 순간에 하나의 쓰레드만 실행될 수 있도록 제한하는 것

<br/>

### 동기화 기법의 종류

<br/>

1. 크리티컬 섹션(Critical Section) 기반의 동기화 - 유저 모드 동기화
    - 메모리 접근 동기화
2. 인터락 함수(Interlocked Family Of Function) 기반의 동기화 - 유저 모드 동기화
    - 메모리 접근 동기화
3. 뮤텍스(Mutex) 기반의 동기화 - 커널 모드 동기화
    - 메모리 접근 동기화
4. 세마포어(Semaphore) 기반의 동기화 - 커널 모드 동기화
    - 메모리 접근 동기화
5. 이름있는 뮤텍스(Named Mutex) 기반의 프로세스 동기화 - 커널 모드 동기화
    - 프로세스 간 동기화
6. 이벤트(Event) 기반의 동기화 - 커널 모드 동기화
    - 실행순서 동기화

<br/>

## 3. 유저 모드의 동기화

<br/>

- 유저 모드 동기화 기법을 적용할 경우, 커널 모드로의 전환이 불필요하므로 성능상의 이점을 얻을 수 있다.
- 커널 모드 동기화에 비해 활용하는 방법도 단순하다.

<br/>

### 크리티컬 섹션 기반의 동기화

<br/>

- 임계 영역을 화장실에 비유하면, 화장실에 들어가기 위해서는 화장실 앞에 걸려있는 열쇠를 가져가야만 한다. 열쇠가 걸려있다면 이 열쇠로 문을 열고 화장실에 들어가면 된다. 화장실 사용이 끝났다면 다시 열쇠를 화장실 앞에 걸어 놓는다.
- 핵심은 열쇠를 얻은 사람만이 화장실에 들어갈 수 있다는 것이다.

<br/>

```C

/*
크리티컬 섹션 기반의 동기화를 사용하기 위한 크리티컬 섹션 오브젝트 생성 및 초기화
이는 화장실 열쇠라고 생각
*/

CRITICAL_SECTION gCriticalSection; // critical section object

/*
앞서 크리티컬 섹션 오브젝트를 선언한 후에는 반드시 아래 함수를 통해서 초기화 과정을 거쳐야만 크리티컬 섹션 오브젝트가 사용 가능한 상태가 됨
*/

void InitializeCriticalSection (
    LPCRITICAL_SECTIOIN lpCriticalSection 
);

// lpCriticalSection: 초기화하고자 하는 크리티컬 섹션 오브젝트의 주소값을 인자로 전달
```

<br/>

```C

/*
앞서 크리티컬 섹션 오브젝트를 선언하고 초기화하여 사용 가능한 상태가 되었으므로, 이는 화장실에 들어가기 위해 열쇠를 화장실 앞에 걸어놓은 상황이다.

이제 화장실에 들어가기 위해서는 열쇠를 사용해야 한다.

이 때, 우리가 취해야 할 행동은 두 가지 이다.

첫 번째로 화장실에 들어가기 위해 열쇠를 획득하는 행위이다.
*/

void EnterCriticalSection (
    LPCRITICAL_SECTION lpCriticalSection
)

/*
lpCriticalSection: 임계 영역(화장실)에 진입하기 위해서 필요한 크리티컬 섹션 오브젝트의 주소값을 인자로 전달한다.

만약 다른 쓰레드에 의해서 이미 이 함수가 호출된 상태라면, 호출된 함수는 블로킹 상태가 된다.

따라서, 함수의 호출에 성공하고 임계 영역으로 들어갔을 때 이를 호출한 쓰레드가 크리티컬 섹션 오브젝트를 획득했다고 표현한다.
*/
```

<br/>

```C

/*
앞서 열쇠를 획득하여 화장실에 들어갔다.

이제 우리가 취해야 하는 두 번째 행동은 다음 사람이 화장실에 들어가기 위해서 화장실에서 나온 후 열쇠를 제자리에 걸어두는 행위이다.
*/

void LeaveCriticalSection (
    LPCRITICAL_SECTION lpCriticalSection
)

/*
lpCriticalSection: 임계 영역을 빠져 나오고 나서 호출하는 함수이다. 이는 화장실에 열쇠를 다시 걸어놓는 역할이다.

앞서 EnterCriticalSection 함수 호출로 인해 블로킹 상태에 놓인 쓰레드가 있다면, LeaveCriticalSection 함수 호출로 인해서 블로킹 상태에서 빠져나와 임계 영역으로 진입하게 된다.

블로킹 상태에서 빠져나왔다는 것은 열쇠를 획득했다는 뜻이고, 이 함수 호출이 완료되면 쓰레드가 크리티컬 섹션 오브젝트를 반환했다고 한다.
*/
```

<br/>

```C
// 임계 영역 진입을 위해서 크리티컬 섹션 오브젝트 획득
EnterCriticalSection(&CriticalSection);

            // 임계 영역

// 크리티컬 섹션 오브젝트 반환
LeaveCriticalSectioin(&CriticalSection);


/*
위의 코드 예시처럼, 임계 영역이 결정되면 'EnterCriticalSection 함수와 LeaveCriticalSection 함수 호출을 통해서 중간의 임계 영역은 한 순간에 하나의 쓰레드만 실행할 수 있도록 구성하는 것이 바로 크리티컬 섹션 동기화 기법의 핵심이다.
*/
```

<br/>

```C
/*
끝으로 초기화 함수가 호출되는 과정에서 할당된 리소스들을 아래 함수를 통해 반환해야 한다.
*/

void DeleteCriticalSection (
    LPCRITICAL_SECTION lpCriticalSection
)
```

<br/>

### 인터락 함수 기반의 동기화

<br/>

- 앞의 예제와 같이 전역으로 선언된 변수 하나의 접근 방식을 동기화하는 것이 목적이라면, 이러한 용도의 특화된 인터락 함수를 사용하는 것도 좋다.
- 인터락 함수는 함수 내부적으로 한 순간에 하나의 쓰레드에 의해서만 실행되도록 동기화되어 있다.

<br/>

```C
LONG InterlockedIncrement (
    LONG volatile* Addend
);

/*
- 값을 하나 증가시킬 32비트 변수의 주소값을 전달한다.
- 둘 이상의 쓰레드가 공유하는 메모리에 저장된 값을 이 함수를 통해서 증가시킬 경우, 동기화된 상태에서 접근하는 것과 동일한 안정성을 보장받을 수 있다.
*/

LONG InterlockedDecrement (
    LONG volatile* Addend
);

/*
- 값을 하나 감소시킬 32비트 변수의 주소값을 인자로 전달한다.
- 둘 이상의 쓰레드가 공유하는 메모리에 저장된 값을 이 함수를 통해서 감소시킬 경우에, 동기화된 상태에서 접근하는 것과 동일한 안정성을 보장받을 수 있다.
*/
```

<br/>

- 위의 두 함수는 원자적 접근(Atomic Access), 즉 한 순간에 하나의 쓰레드만 접근하는 것을 보장해 주는 함수이다. 따라서 모든 쓰레드가 이 함수들을 통해서 값을 하나 증가시키거나 감소시킬 경우, 동시에 둘 이상의 쓰레드 접근에 의한 문제는 결코 발생하지 않는다.
- 마이크로소프트에서는 보다 다양한 인터락 함수들을 제공한다.
    - 값을 원하는 만큼 증가 및 감소시키는 함수
    - 64비트 변수를 대상으로 연산하는 데 사용 가능한 함수

<br/>

**volatile**

<br/>

- C, C++ 언어의 ANSI 표준 키워드이다.

<br/>

1. 최적화를 수행하지 마라!

<br/>

- 컴파일러는 프로그래머가 프로그래밍한 코드를 컴파일하는 과정에서 코드의 최적화를 수행한다.

<br/>

```C
int function (void)

{
    int a = 10;
    a = 20;
    a = 30;
    cout<<a;
}

int function (void)
{
    int a = 30;
    cout<<a;
}

/*
변수 a의 값을 10에서 20, 그리고 다시 30으로 변경하는 과정은 결과만 두고 본다면 불필요한 일이다. 따라서 컴파일 과정에서 프로그램의 실행결과가 동일하다는 관점에서 최적화가 이루어질 수도 있다.
*/
```

<br/>

- 하지만 이러한 최적화가 문제가 되는 상황이 있다.
- 임베디드 시스템을 구성할 때에는 메모리 맵을 디자인하는 과정을 거치는데, 이 과정에서 출력을 위해 사용되는 하드웨어 장치에도 주소를 할당하게 된다.
- 즉, 메모리 주소가 RAM과 같은 저장장치에만 할당되는 것이 아닌, 하드웨어 장치에도 할당이 된다.

<br/>

```C
int function (void)
{
    int * pSound = 0x30000; // 오디오 장치의 주소 값 지정
    * pSound = 1; // 오디오 장치에 '도' 음을 내기 위해 1 전송
    * pSound = 2; // 오디오 장치에 '미' 음을 내기 위해 2 전송
    * pSound = 3; // 오디오 장치에 '솔' 음을 내기 위해 3 전송
    * pSound = 1; // '도' 음을 내기 위해 다시 1 전송
}

/*
위 함수를 최적화를 수행하게 되면 아래와 같은 현상이 발생한다.
*/

int function (void)
{
    int volatile * pSound = 0x30000;
}

/*
이렇게 되면 컴파일러 입장에서는 0x30000번지에 최종적으로 들어가는 값이 1이라고 생각하고 그 사이에서 벌어지는 일들을 모두 생략한다.
따라서, 이 코드는 '도' 음 하나만 발생시킨다.
*/
```

<br/>

- 이러한 상황에서 '제발 최적화를 수행하지 말아주세요'라고 부탁하는 키워드가 바로 **volatile**이다.

<br/>

```C
int function (void)
{
    int volatile * pSound = 0x30000;
}

/*
위 코드와 같이 포인터 pSound를 volatile로 선언할 경우에는 컴파일러는 이 포인터를 기반으로 하는 모든 연산에 대해서 최적화를 고려하지 않는다.
*/
```

<br/>

2. 메모리에 직접 연산하라!

<br/>

```C

/*
정확히 3시 35분 12초에 '미'라는 음을 내는 프로그램을 작성
*/

int function (void)
{
    int * pSound = 0x30000;
    SleepUntil(3, 35, 12);
    * pSound = 2;
}

/*
하지만 이 함수에서는 pSound가 가리키는 주소 0x30000에 데이터가 입력되면서 '미' 음이 발생하지 않는다.

이는 성능 향상을 위해서 동작중인 캐쉬 매니저가 값을 메모리(임베디드 시스템 오디오)에 저장한 것이 아닌, 캐쉬 메모리에 저장했기 때문에 원하는 시점에 '미' 음을 들을 수 없다.
*/
```

<br/>

- 위와 같은 문제를 막기 위해서 volatile 키워드를 사용한다.
- volatile 키워드로 선언되면 해당 데이터는 절대로 캐쉬되지 않는다.
- 따라서, 해당 포인터가 volatile로 선언되었을 때 이 포인터가 가리키는 메모리 공간으로 전송되는 데이터인 2는 0x30000번지에 저장하는 순간 오디오 칩으로의 데이터 전송이 바로 이루어진다.

<br/>

**volatile 키워드를 이용하면 함수 내부적으로 최적화를 수행하지 않으며, 해당 포인터가 가리키는 메모리 영역을 캐쉬하지 않겠다는 것을 의미한다. 그리고 변수를 직접 volatile로 선언했을 때, 선언된 변수의 주소값을 인자로 전달할 필요는 없다.**