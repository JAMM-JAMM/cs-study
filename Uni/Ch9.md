# 9장. 프로세스의 스케줄링(Scheduling)

<br/>

- 대부분의 운영체제는 멀티 프로세스 기반 운영체제이며, 실행중인 모든 프로세스들에게 골고루 CPU를 할당하는 일은 운영체제의 일부분에 담당하는 **스케줄러**가 담당하는 일이다.

<br/>

## 1. 일반 OS와 리얼타임(Real Time) OS의 차이점

<br/>

### RTOS와 일반 OS의 차이는 응답성(응답속도)에 있다.

<br/>

- RTOS는 응답성이 Windows와 같은 일반 OS보다 좋다.

<br/>

### Windows나 Linux와 같은 일반 OS는 특수한 목정이 정해져 있는 OS가 아닌 범용적인 사용을 위해서 디자인 된 OS이다.

<br/>

- 컴퓨터를 잘 모르는 사람도 쉽게 사용할 수 있도록 디자인되어 있는 OS이기 때문에, 사용자가 명령하는 일 이외에도 하는 일이 많다.
- 따라서, 눈에 보이지 않지만 현재 진행중인 일이 많기 때문에 일에 대한 응답성이 RTOS에 비해서 상대적으로 느리다.

<br/>

### RTOS는 범용적인 OS보다 하는 일이 적고, 사용하는 영역이 제한적이다.

<br/>

- 일반적인 OS에 반해서 RTOS는 프로그래머가 시키지 않은 일은 하지 않는다.
- 따라서, 시키는 일에 대한 응답성이 일반적인 OS에 비해서 상대적으로 빠르다.

<br/>

### RTOS는 일반 OS에 비해서 속도가 빠른 것이 아니다.

<br/>

- 사용되는 목적이 구체적이고 제한적이기 때문에 보다 단순하게 디자인되어 있고 일반 OS에 비해서 훨씬 가벼우므로 응답성이 좋다.

<br/>

## 2. Soft RTOS vs Hard RTOS

<br/>

### Soft RTOS

<br/>

- 앞서 설명한 RTOS는 일반 OS와 별 차이가 없지만, 하는 일이 특화되어 있기 때문에 일반 OS에 비해서 단순이 응답성이 좋은 것 뿐이라고 했다. 이러한 RTOS를 가리켜 Soft RTOS라고 한다. 
- 우리가 접하는 대부분의 RTOS는 Soft RTOS이다.

<br/>

### Hard RTOS

<br/>

- 전통적으로 말하는 RTOS는 Hard RTOS이다.
- 일반 OS에 비해서 단순히 응답성이 좋은 정도로 설명되지 않고, **데드라인**을 중요하게 생각한다.
- 데드라인은 정말로 시간에 Critical한 상황에서 발생하고, 이러한 능력을 충족시키는 RTOS를 가리켜 Hard RTOS라고 한다.
- 데드라인 충족은 단순히 CPU의 속도가 빠르다고 해서 만족되는 것이 아니기 때문에 Hard RTOS를 디자인하는 것은 결코 쉬운 일이 아니며, 일반 OS와는 전혀 다른 알고리즘으로 스케줄러가 디자인되어야 한다.

<br/>

## 3. 선점형(Preemptive) OS와 비선점형(Non-Preemptive) OS

<br/>

- 프로세스의 실행을 다른 프로세스로 넘기는 방식에 따라서 선점형 OS와 비선점형 OS를 구분한다.

<br/>

### 비선점형 OS

<br/>

- 비선점형 OS는 현재 실행중인 프로세스보다 높은 우선순위으 프로세스가 등장한다고 해서 실행의 대상을 바로 변경하지 않는다.
- 새로 등장한, 보다 높은 우선순위의 프로세스가 실행되기 위해서는 현재 실행중인 프로세스가 명시적으로 CPU를 양보할 때 까지 또는 I/O 작업 등으로 현재 실행중인 프로세스가 블로킹 상태에 놓일 때 까지 기다려야 한다.
- 오늘 날 대부분의 OS는 프로그래머가 사용하는 키보드, 혹은 마우스 입력에 민감하게 반응하고 프로그래머와 대화를 계속하면서 그 결과에 따라 프로그램을 구동하는데, 이러한 시스템을 인터렉티브 시스템이라고 한다. 비선점형 OS의 경우 이러한 인터렉티브한 프로그램을 구현 시 프로그래머의 의존도가 높아지는 문제점이 생긴다.

<br/>

### 선점형 OS

<br/>

- 선점형 OS는 현재 실행중인 프로세스보다 높은 우선순위의 프로세스가 등장하면 스케줄러에 의한 실행순서 조정이 적극적으로 가해진다.
- 비선점형 OS에 비해서 선점형 OS는 스케줄러에 의해 프로세스의 우선순위에 의한 실행순서가 적절하게 조절되므로, 스케줄러의 하는 일이 많다.
- 따라서, 오늘 날 대부분 사용되는 둘 이상의 프로세스를 동작시키는 멀티 프로세스 기반 OS에 적합하다.
- 오늘 날 우리가 접하는 모든 OS(Windows)는 선점형 OSdlek.
- RTOS도 선점형 OS에 포함된다.

<br/>

## 4. 우선순위(Priority) 스케줄링 알고리즘

<br/>

- Windows에서 채택하고 있는 대표적인 선점형 스케줄링 알고리즘 중 하나인 우선순위 스케줄링 알고리즘은 **각각의 프로세스마다 우선순위를 부여해서 우선순위가 높은 프로세스를 먼저 실행시키는 방식**이다.

<br/>

### 우선순위가 7인 프로세스와 우선순위가 2인 프로세스를 동시에 실행시키면 어떻게 될까?

<br/>

**1. 보편적인 운영체제에서는 우선순위가 2인 프로세스는 결코 실행되지 않는다.**

<br/>

- 우선순위 스케줄링 알고리즘은 우선순위가 높은 프로세스를 먼저 실행하는 알고리즘이기 때문에, 우선순위가 높은 프로세스가 작업을 마쳐야 그 다음 우선순위의 프로세스가 실행되기 때문
- 이 때, 우선순위 2인 프로세스는 기아(Starvation) 상태에 빠지게 된다.

<br/>

**2. 높은 우선순위 프로세스가 I/O 관련 작업을 하는 과정에서, 낮은 우선순위 프로세스가 실행 기회를 얻을 수 있다.**

<br/>

- 대부분의 프로그램은 상당 시간을 I/O에 할애하게끔 설계되어 있기 때문에, 의외로 쉽게 낮은 우선순위 프로세스가 실행 기회를 얻을 수 있다.
- 즉, 낮은 우선순위의 프로세스가 기아(Starvation) 상태에 빠지는 것은 생각보다 드문 일이다.

<br/>

## 5. 라운드 로빈(Round-Robin) 스케줄링 알고리즘

<br/>

- Windows에서 채택하고 있는 대표적인 선점형 스케줄링 알고리즘 중 하나인 라운드 로빈 스케줄링 알고리즘은 **우선순위가 동일한 프로세스의 경우, 형평성 유지를 위해서 정해진 시간 간격만큼만 실행을 하고 우선순위가 동일한 다른 프로세스에게 CPU의 할당을 넘기는 방식**을 제공한다.
- 실행의 최소 단위 시간 간격을 가리켜 퀀텀(Quantum) 혹은 타임 슬라이스(Time Slice)라 한다.
- 동일한 우선순위으 모든 프로세스들은 이 타임 슬라이스를 기준으로 CPU의 할당을 넘기게 된다.
    - 타임 슬라이스를 길게 하면 마우스로 드래그 앤 드롭을 하는 반응과 같은 인터렉티브한 시스템에서 문제가 발생할 수 있다.
    - 타임 슬라이스를 짧게 하면 그만큼 컨텍스트 스위칭이 자주 발생해서 성능에 저하를 가져다 준다.

<br/>

**Windows는 우선순위 기반과 라운드 로빈 기반 알고리즘을 적절히 혼용하여 선점형 운영체제 특성을 나타내도록 디자인되었다.**

<br/>

## 6. 스케줄링 알고리즘에 의해서 스케줄링이 진행되는 시점

<br/>

### 선점형 운영체제(OS)를 디자인하는 상황에서, 어느 시점에 스케줄러가 동작하도록 디자안하면 좋을까?

<br/>

**라운드 로빈 방식의 스케줄링 알고리즘 관점**

<br/>

- 라운드 로빈 방식의 스케줄링은 타임 슬라이스를 기준으로 스케줄링이 동작한다.
- 따라서, 정해진 시간이 지나고 다음 프로세스에게 실행 순서를 넘길 때 즉, 프로세스의 실행시간 간격에 해당하는 매 타임 슬라이스마다 스케줄러는 동작해야 한다.

<br/>

**우선순위 방식의 스케줄링 알고리즘 관점**

<br/>

- 새로운 프로세스가 등장할 때 마다, 현재 실행중인 프로세스와 새로운 프로세스의 우선순위를 비교해야 하므로 새로운 프로세스가 생성될 때 마다 스케줄러가 동작해야 한다.
- 현재 실행중인 프로세스가 종료될 때, 다른 프로세스를 실행시켜야 되므로 이 때에도 스케줄러가 동작해야 한다.

<br/>

**블로킹 상황**

<br/>

- 현재 실행중인 프로세스가 블로킹 상태에 놓이면, 다음 실행될 프로세스 선정을 위해 스케줄러가 동작해야 한다.

<br/>

## 7. Priority Inversion

<br/>

- 정해진 프로세스의 우선순위가 뒤바뀌는 현상
- 이 문제에 대한 해결방법은 운영체제별로 다양하다.