### 동기화와 임계 영역

- 임계 영역 : 둘 이상의 쓰레드가 동시에 접근할 위험 요소를 지는 코드 블럭
- 동기화 : 메모리 접근에 있어 동시 접근을 막거나 쓰레드의 실행 순서를 정의하고 이 순서를 따르도록 하는 것

#### 동기화 기법의 종류

- 메모리 동기화 기법
  - 유저 모드 동기화
    - 커널 코드가 실행되지 않기 때문에 동기화를 위해 커널 모드로 전환히 불필요하여 성능상에 이점이 있음
    - 크리티컬 섹션 기반 동기화
    - 인터락 함수 기반 동기화
  - 커널 모드 동기화
    - 커널에서 제공하는 동기화 기능을 사용하기 때문에 성능의 저하가 있지만 유저 모드 동기화에서 제공하지 못하는 기능을 사용할 수 있음
    - 뮤텍스 기반 동기화
    - 세마포어 기반 동기화
    - 이름 있는 뮤텍스 기반 동기화
- 실행 순서 동기화 기법
  - 이벤트 기반 동기화



### 메모리 동기화 기법

#### 유저모드 동기화

- **크리티컬 섹션 기반 동기화**
  - key : 둘 이상의 쓰레드 접근을 막기 위해 열쇠를 이용한다고 생각하면 됨
  - CRITICAL_SECTION : 크리티컬 섹션 기반의 동기화에서의 키
  - 임계영역은 최소한으로 해야 효율적
  - 크리티컬 섹션이 넓으면 둘 이상의 쓰레드가 접근할 수 있는 범위가 제한되어 성능 저하
- **인터락 함수 기반 동기화**
  - 크리티컬 섹션 기반 동기화를 하나의 함수로 구현
  - 작은 영역의 코드블럭에 대해 동기화하기 용이
  - 원자적 접근을 보장 : 한 순간에 하나의 쓰레드에 의해서만 호출하도록 허용



### 커널모드 동기화

- **뮤텍스 기반 동기화**
  - CreateMutex : 열쇠를 생성하는 함수
  - 커널 오브젝트 생성을 동반하기 때문에 핸들도 반환되고 핸들 테이블의 상속을 결정하는 보안 설정을 함
  - 소유자를 지정하면 열쇠를 만든사람이 소유하는지 열쇠를 만든 사람도 소유의 권한을 가지지 않고 누구나 소유할 수 있는 지를 결정
  - WaitForSingleObject(), ReleasMutex()를 통해서 뮤텍스(열쇠)를 획득하고 반납
  - 뮤텍스를 커널 오브젝트라고 생각하면 WaitForSingleObject()가 빠져나오기 위해선 뮤텍스가 Signaled 상태가 되야 함
  - ReleaseMutex()는 뮤텍스를 Signaled 상태가 되게 하는 함수
  - WaitForSingleObject()는 뮤텍스를 Non-Signaled 상태로 바꾸게 되는 함수
  - 쓰레드가 임계 영역으로 들어가기 전 뮤텍스를 얻기 위해 뮤텍스 핸들을 인자로 전달하면서 WaitForSingleObject() 함수를 호출하고 뮤텍스가 획득 가능 상태라면 Signaled 상태에 있고 뮤텍스를 획득하면서 임계 영역에 진입
  -  WaitForSingleObject 함수는 매개변수로 호출한 오브젝트가 Signaled 상태가 되기를 기다리기 때문에 다른 쓰레드는 임계 영역으로의 진입이 불가능
  - 임계 영역에 진입한 쓰레드가 빠져나오면서 ReleaseMutex 함수를 호출하면 뮤텍스는 Signaled 상태가 되어 다른 쓰레드가 획득할 수 있게 되어 다른 쓰레드의 진입을 허용함
- **세마포어 기반 동기화**
  - WaitForSingleObject, ReleaseSemaphore 함수가 호출되면 세마포어 카운트가 감소 or 증가됨
  - 세마포어 카운트 값이 0이 되지 않는 이상 Non-signaled 상태가 되지 않음
  - Signaled 상태로 계속 있기 때문에 WaitForSingleObject를 호출해도 임계 영역에 다른 쓰레드도 진입 가능
  - 생성하는 쓰레드의 개수 : <span style="color: #333333;">NUM_OF_CUSTOMER</span>
  - 임계영역에 한번에 접근할 수 있는 쓰레드의 수 = TABLE_CNT
  - 처음에 실행하면 20개중 10개의 쓰레드가 임계 영역에 진입하고 세마포어 카운트가 0이 됨
  - 주어진 Sleep 시간 이후 임계 영역을 나오면서 ReleaseSemaphore 함수를 통해 세마포어 카운드를 증가시킴
  - 쓰레드가 빠져 나오면 기다리고 있던 쓰레드가 다시 들어가고 세마포어 카운트가 증가
  - 이후 모든 쓰레드가 진입 후 나오게 되면서 세마포어 카운트가 다시 TABLE_CNT가 됨
- **이름 있는 뮤텍스 기반의 프로세스 동기화**
  - 동기화 하고 싶은 쓰레드가 다른 프로세스에 있을 때 사용
  - 프로세스 A에서 생성한 뮤텍스는 프로세스 A의 쓰레드는 접근이 가능하지만 프로세스 B의 쓰레드는 접근이 불가능
  - 뮤텍스 핸들 값은 프로세스 A에서만 고유한 값이기 때문에 핸들 값을 넘겨준다 해도 의미가 없음
  - 동기화를 위해서는 프로세스 A 핸들 테이블에 저장된 뮤텍스의 정보를 등록해야 함
  - 프로세스 내의 쓰레드 간의 동기화를 위해서는 핸들을 이용했지만 다른 프로세스에는 뮤텍스의 핸들 정보가 등록이 되어 있지 않기 때문에 뮤텍스에 설정된 이름을 통해 접근
- **뮤텍스 소유와 WAIT_ABANDONED**
  - 소유의 관점에서 세마포어와 뮤텍스의 차이점
  - 뮤텍스 : 열쇠를 얻은 쓰레드가 반환을 해야함
  - 세마포어 : 열쇠를 여러개 가지고 공유를 하기 때문에 얻은 쓰레드가 꼭 반환하지 않아도 됨
    WAIT_ABANDONED
  - A 쓰레드가 열쇠를 얻고 임계영역에 들어가 있고 B 쓰레드가 WaitForSingleObject 호출 후 대기하고 있을 때 열쇠를 가지고 있는 쓰레드가 열쇠를 반환하지 않고 사라지는 경우 B 쓰레드가 반환값으로 WAIT_ABANDONED 값을 얻게 됨
  - A 쓰레드의 비정상적 종료로 인해 뮤텍스 반환이 적절치 이루어지지 않았기 때문에 열쇠를 OS 가 B 쓰레드에 열쇠를 넘겨준다는 의미
