### 컴퓨터 구조(CPU)의 접근방법

#### 컴퓨터 디자인

- 하드웨어, 알고리즘, 인터페이스, 프로그래머(특성을 잘 아는) 전문가들이 모여 설계
- 레지스터와 명령어(컴파일러를 통해 만들어지는 명령어의 집합) 디자인
  - 초기 단계부터 구성
- 명령어를 프로그래머들이 디자인

#### 레지스터 디자인의 핵심

- 레지스터 : 특별한 목적을 가지고 있는 메모리 장소
- 레지스터의 비트 수 (n 비트 시스템 = 명령어의 길이 n 비트 = n 비트 레지스터)
- 레지스터의 개수 (다다익선)
- 레지스터의 용도 (개수마다 각각의 용도를 지정)

#### 명령어 구조 및 명령어 디자인

- 명령어 기본 모델 (명령어 길이 = 레지스터 길이)
- 사칙연산 명령어 구성
  - 예약
  - 연산자
  - 저장소 (레지스터에 저장)
  - 피연산자1 (피연산자에는 레지스터 or 숫자 / 구분을 위해서 처음 비트를 지정)
  - 피연산자2
- ALU가 명령어를 해독 (그래서 명령어 디자인이 정해져야됨)
- 명령어에 따라 조합이 달라짐
- 명령어를 왜 단순하게 ?
  - 명령어가 단순한 CPU 구조 = RISK(단순하지만 제약) ↔ CISK (명령어가 복잡, 마음대로 사용가능) 
  - 고성능에 적합, 속도가 빠름
  - Fetch, Decode, Execution 각각의 단계마다 1개의 클럭 사용
  - 여러 명령어 동시에 실행 가능 ex)F D E 을 조합해서 동시 실행
  - 클럭 수 많다고 좋은 것 X, 요즘은 클럭 수 ↓ + 최대한 많은 명령어 수행되게 디자인



### LOAD & STORE 명령어 디자인

#### LOAD 명령어

- 피연산자 값을 레지스터(메인 메모리)로 불러들이는 명령어
- 명령어 구조 (예약 + LOAD + destination + source) 피연산자 필요 X
- destination: 데이터를 저장할 레지스터 정보
- source: 데이터를 읽어올 메모리의 주소 정보

#### STORE 명령어

- 연산 결과를 레지스터로 저장하는 명령어
- 명령어 구조 (예약 + STORE +  source + destination)
- source: 데이터를 읽어올 레지스터 정보
- destination: 데이터를 저장할 메모리의 주소 정보

#### LOAD & STORE 명령어의 필요성

- 명령어의 제한
  - 사칙연산의 피 연산자는 숫자 or 레지스터
  - 연산결과는 레지스터에 저장
  - 즉 레지스터를 통해서 모든 연산을 진행( => 따라서 LOAD & STORE 명령어가 필요)



### Direct 모드와 Indirect 모드(메모리를 참조하는 방법)

#### Direct 어드레싱 모드

- 메모리의 주소값을 직접 지정해서 값을 가져옴(바로 값 저장)

#### Indirect 모드

- 메모리 주소에 있는 번지수를 참조하여 해당 번지에 있는 값을 저장(값의 주소를 저장)

#### 문제점

- 현재 비트 수로 표현과 구현에 한계

#### 문제점 해결

- 표현하지 못하는 수를 조합하고 주소값을 저장해서 해결

- 예시

  ```
  LOAD r1, 0x0010 (0x0010 에 있는 피연산자 호출하여 r1에 할당)
  
  MUL r0, 4, 4 (4와 4를 곱해서 16을 r0에 할당)
  MUL r2, 4, 4 (4와 4를 곱해서 16을 r2에 할당)
  MUL r3, r0, r2 (r0와 r2를 곱해서 256(0x100)을 r3에 할당)
  
  STORE r3, 0x0030 (r3의 값을 0x0030 에 저장)
  LOAD r2, [0x0030] (0x0030 에 있는 번지수를 참조하여 그 값을 r2에 할당)
  
  ADD r3, r1, r2
  ```

  

