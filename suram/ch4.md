

# 4장. 컴퓨터 구조에 대한 두 번째 이야기

> section1. cpu 명령어 디자인하기

1. CPU 구성 

    ![https://media.cheggcdn.com/media%2Fa6c%2Fa6ce93c0-67a6-4be7-9c48-00c13e2dc858%2Fphp6JGYLW.png](https://media.cheggcdn.com/media%2Fa6c%2Fa6ce93c0-67a6-4be7-9c48-00c13e2dc858%2Fphp6JGYLW.png)

    - ALU : 실제 명령어를 처리한다.
    - Register : 연산에 필요한 연산자/피연산자들이 저장되는 곳. (CPU내의 저장소)
    - Control unit : 명령어를 해석하고 명령을 내린다.

 CPU는 명령어를 처리하는 연산을 하는 장치이다. 따라서 `명령어` 를 어떻게 구성하고 정의하는지를 알아야 CPU가 어떻게 명령어를 내부적으로 이해하고 처리하는지 알 수 있다. 명령어의 구조는 레지스터의 구조와 상관이 있다. 레지스터의 구조에 따라서 명령어의 구조가 결정된다. 레지스터가 16비트로 구성된다고 했을 때, 구역을 나누어서 연산자, 피연산자가 저장될 비트들을 할당한다. 

```jsx
r2 = r1 + r4
```

(레지스터1과 레지스터4에 저장된 값을 덧셈 연산 후 레지스터2에 저장한다.) 

여기서 r1, r4는 피연산자이거 덧셈은 연산자이다. 피연산자 두개가 각각 4비트 결과값이 저장될 레지스터 3비트 연산자 3비트씩 할당된다고 가정했을 때 총 16비트 중 14비트가 할당된 셈이다. 

```jsx
| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 0 | 1 | 0 | 1 | 1 | 1 |
--에약-- ---연산자--- ----피연산자--------피연산자---- ---결과값---
```

 

16비트가 하나의 명령어를 나타난다고 했을 때 CPU는 이런 명령어의 구조를 알고 있어야 한다는 제약사항이 존재한다. (각 구역의 의미, 피연산자의 첫번째 비트의 의미 등등) 

> section2. LOAD&STORE

명령어를 정의하는 과정에서 제약사항이 생긴다. 피연산자와 결과가 레지스터에만 저장된다는 제약사항이 존재한다. 이런 경우에 메인 메모리에 있는 값들을 레지스터에 가져오고 (LOAD) 결과값을 다시 메인 메모리에 저장(STORE)하는 과정이 필요하다. *메인 메모리 = 램 그러니까 앞 장에서 정의한 명령어들 이전/이후에 수행된다. 

LOAD, STORE 명령어를 처리하기 위한 명령어 정의가 별도로 필요하다. 

```jsx
LOAD r3 0x07 : 0x07(메인 메모리)번지에 있는 데이터를 레지스터 3에 저장하라. 
```

> section3. Direct/Indirect 모드

데이터를 접근/표현하기 위한 방법. 하나의 명령어에 여러 정보를 담다보니 표현하는 데이터 크기에 제한이 따른다는 문제점에 등장. Direct(비트수에 따라 표현할 수 있는 값의 범위가 정해짐)→ Indirect

- Direct : 주소값을 저장하고 이를 참조하고 바로 접근한다.
- Indirect : 주소값을 가지고 있는 메모리의 위치를 저장한다.



