## 프로세스와 쓰레드 


> **Thread**

- 멀티 프로세스 : cpu가 여러 개의 프로그램을 실행시키기 위함.
- 프로세스는 기본적으로 코드 실행 즉 하나의 흐름.
- 하나의 프로세스에서 여러 개의 흐름으로 나뉜다면?
- 프로세스는 메모리를 할당 받는다.
    - `Code` : 프로그램 코드
    - `Data` : 전역변수
    - `Heap` : 동적할당
    - `Stack` : 지역변수, 매개변수 (쓰레드 별도 할당)
- 흐름을 2개 갖기 위해서 자식 프로세스를 생성하는 것은 문제가 없을까?  → 프로세스가 많아지면 컨텍스트 스위칭이 빈번하게 발생 → 시스템에 부담.
- 코드 실행은 함수 호출의 연속 → stack 필요
- 각 흐름별로 스택을 독립시켜 분리한다면 시스템이 관리하기가 쉬워짐. 데이터 접근, 순서 등이 쉬워짐. 로직별로 분리되어 있기 때문에. 각각을 위한 스택을 별도로 관리하는 것.
- 쓰레드 : 부모 프로세스의 code 영역을 공유하고, 별도 수행에 필요한 각자 필요한 영역은 stack으로 분리하는 실행 단위.
- 공유한다 : 할당받은 메모리 영역을 같이 사용한다.
- 프로세스와 다수의 쓰레드를 합쳐서 하나의 프로세스

> 프로세스와 차이점

- 스레드들은 서로의 코드를 공유하기 때문에 다른 실행 흐름의 함수 호출이 가능함.
- 그러나 부모 프로세스는 자식 프로세스의 코드영역의 함수 호출 불가능. → 프로세스들 간에는 공유하지 않기 때문에 별도의 통신 기법인 IPC를 사용해야 함.

> 윈도우에서의 프로세스와 쓰레드

스케줄러는 프로세스들을 스케줄링하지만 사실은 쓰레드들을 스케줄링하고 있는 것이다. 여러 개의 쓰레드가 프로세스를 구성하기 때문. 

 

> 커널 레벨 vs 유저 레벨 쓰레드

운영체제 (겨의 = 커널)

- 멀티 프로세싱 지원 여부
- 쓰레드 지원 여부
- 쓰레드를 지원하지 않는 운영체제인 경우 개발자가 제어해야함. 라이브러리 사용.

1. 커널 레벨
    - 커널이 쓰레드를 직접 관리함.
    - 쓰레드 존재와 관련 정보를 커널이 알고 있음.
    - 쓰레드 별로 실행 시간을 할당 받음
    - 실행 중인 쓰레드가 블로킹 되면 다른 쓰레드가 실행됨.

2. 유저 레벨 
    - 커널은 단순히 프로세스를 관리할 뿐 쓰레드의 존재를 모름.
    - 프로세스가 자체적으로 쓰레드를 돌림
    - 프로세스별로 실행시간을 할당 받기 때문에 프로세스가 할당 받은 시간 내에서 쓰레드 별로 또 실행 시간을 나누게 됨. (=모든 쓰레드가 동일하게 실행 시간을 나눠갖지 않음)
    - 단위가 프로세스이기 때문에 실행중인 쓰레드가 블로킹되면 다른 프로세스에게 실행이 넘어가서 같이 실행중이던 같은 프로세스 내의 다른 쓰레드가 실행이 멈춤. (문제점)
    - 빠르다

    > 커널 모드 vs 유저 모드

    실행 상태 : 커널 모드 / 유저 모드 

    영역 : 실행되기 위한 공간 (단순히 코드 저장소 이상의 개념) 

    유저 영역 / 커널 영역이 분리

    - 두 영역 모두 연속적인 메모리 공간에 할당되어 있다.
    - 따라서 유저 영역이 간혹 커널의 주소값에 접근할 수도 있다. (오류 일으킬 위험)

    프로그램이 실행될 될 때 두 가지 모드로 실행하도록 하여 문제 방지. 

    - 유저 모드 : 유저 영역의 메모리 공간만 접근 가능
    - 커널 모드 : 모든 메모리 공간 접근 가능
    - 쓰레드 관리를 커널 레벨 쓰레드에서 하기 때문에 쓰레드 컨텍스트 스위칭이 빈번히 일어남. 유저레벨 → 커널레벨로 모드가 마뀌기 때문에
    - 모드 변경이 일어나지 않기 때문에 유저 레벨 쓰레드가 속도가 더 빠름.
